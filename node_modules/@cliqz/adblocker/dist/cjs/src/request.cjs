'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var guessUrlType = require('@remusao/guess-url-type');
var tldtsExperimental = require('tldts-experimental');
var dataView = require('./data-view.cjs');
var tokensBuffer = require('./tokens-buffer.cjs');
var utils = require('./utils.cjs');

/*!
 * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const TLDTS_OPTIONS = {
    extractHostname: true,
    mixedInputs: false,
    validateHostname: false,
};
const NORMALIZED_TYPE_TOKEN = {
    beacon: utils.fastHash('type:beacon'),
    cspReport: utils.fastHash('type:csp'),
    csp_report: utils.fastHash('type:csp'),
    cspviolationreport: utils.fastHash('type:cspviolationreport'),
    document: utils.fastHash('type:document'),
    eventsource: utils.fastHash('type:other'),
    fetch: utils.fastHash('type:xhr'),
    font: utils.fastHash('type:font'),
    image: utils.fastHash('type:image'),
    imageset: utils.fastHash('type:image'),
    mainFrame: utils.fastHash('type:document'),
    main_frame: utils.fastHash('type:document'),
    manifest: utils.fastHash('type:other'),
    media: utils.fastHash('type:media'),
    object: utils.fastHash('type:object'),
    object_subrequest: utils.fastHash('type:object'),
    other: utils.fastHash('type:other'),
    ping: utils.fastHash('type:ping'),
    prefetch: utils.fastHash('type:other'),
    preflight: utils.fastHash('type:preflight'),
    script: utils.fastHash('type:script'),
    signedexchange: utils.fastHash('type:signedexchange'),
    speculative: utils.fastHash('type:other'),
    stylesheet: utils.fastHash('type:stylesheet'),
    subFrame: utils.fastHash('type:subdocument'),
    sub_frame: utils.fastHash('type:subdocument'),
    texttrack: utils.fastHash('type:other'),
    webSocket: utils.fastHash('type:websocket'),
    web_manifest: utils.fastHash('type:other'),
    websocket: utils.fastHash('type:websocket'),
    xhr: utils.fastHash('type:xhr'),
    xml_dtd: utils.fastHash('type:other'),
    xmlhttprequest: utils.fastHash('type:xhr'),
    xslt: utils.fastHash('type:other'),
};
function hashHostnameBackward(hostname) {
    let hash = utils.HASH_SEED;
    for (let j = hostname.length - 1; j >= 0; j -= 1) {
        hash = (hash * utils.HASH_INTERNAL_MULT) ^ hostname.charCodeAt(j);
    }
    return hash >>> 0;
}
function getHashesFromLabelsBackward(hostname, end, startOfDomain) {
    tokensBuffer.TOKENS_BUFFER.reset();
    let hash = utils.HASH_SEED;
    // Compute hash backward, label per label
    for (let i = end - 1; i >= 0; i -= 1) {
        const code = hostname.charCodeAt(i);
        // Process label
        if (code === 46 /* '.' */ && i < startOfDomain) {
            tokensBuffer.TOKENS_BUFFER.push(hash >>> 0);
        }
        // Update hash
        hash = (hash * utils.HASH_INTERNAL_MULT) ^ code;
    }
    tokensBuffer.TOKENS_BUFFER.push(hash >>> 0);
    return tokensBuffer.TOKENS_BUFFER.slice();
}
/**
 * Given a hostname and its domain, return the hostname without the public
 * suffix. We know that the domain, with one less label on the left, will be a
 * the public suffix; and from there we know which trailing portion of
 * `hostname` we should remove.
 */
function getHostnameWithoutPublicSuffix(hostname, domain) {
    let hostnameWithoutPublicSuffix = null;
    const indexOfDot = domain.indexOf('.');
    if (indexOfDot !== -1) {
        const publicSuffix = domain.slice(indexOfDot + 1);
        hostnameWithoutPublicSuffix = hostname.slice(0, -publicSuffix.length - 1);
    }
    return hostnameWithoutPublicSuffix;
}
function getEntityHashesFromLabelsBackward(hostname, domain) {
    const hostnameWithoutPublicSuffix = getHostnameWithoutPublicSuffix(hostname, domain);
    if (hostnameWithoutPublicSuffix !== null) {
        return getHashesFromLabelsBackward(hostnameWithoutPublicSuffix, hostnameWithoutPublicSuffix.length, hostnameWithoutPublicSuffix.length);
    }
    return dataView.EMPTY_UINT32_ARRAY;
}
function getHostnameHashesFromLabelsBackward(hostname, domain) {
    return getHashesFromLabelsBackward(hostname, hostname.length, hostname.length - domain.length);
}
function isThirdParty(hostname, domain, sourceHostname, sourceDomain, type) {
    if (type === 'main_frame' || type === 'mainFrame') {
        return false;
    }
    else if (domain.length !== 0 && sourceDomain.length !== 0) {
        return domain !== sourceDomain;
    }
    else if (domain.length !== 0 && sourceHostname.length !== 0) {
        return domain !== sourceHostname;
    }
    else if (sourceDomain.length !== 0 && hostname.length !== 0) {
        return hostname !== sourceDomain;
    }
    return false;
}
class Request {
    /**
     * Create an instance of `Request` from raw request details.
     */
    static fromRawDetails({ requestId = '0', tabId = 0, url = '', hostname, domain, sourceUrl = '', sourceHostname, sourceDomain, type = 'main_frame', _originalRequestDetails, }) {
        url = url.toLowerCase();
        if (hostname === undefined || domain === undefined) {
            const parsed = tldtsExperimental.parse(url, TLDTS_OPTIONS);
            hostname = hostname || parsed.hostname || '';
            domain = domain || parsed.domain || '';
        }
        // Initialize source URL
        if (sourceHostname === undefined || sourceDomain === undefined) {
            const parsed = tldtsExperimental.parse(sourceHostname || sourceDomain || sourceUrl, TLDTS_OPTIONS);
            sourceHostname = sourceHostname || parsed.hostname || '';
            sourceDomain = sourceDomain || parsed.domain || sourceHostname || '';
        }
        return new Request({
            requestId,
            tabId,
            domain,
            hostname,
            url,
            sourceDomain,
            sourceHostname,
            sourceUrl,
            type,
            _originalRequestDetails,
        });
    }
    constructor({ requestId, tabId, type, domain, hostname, url, sourceDomain, sourceHostname, _originalRequestDetails, }) {
        // Lazy attributes
        this.tokens = undefined;
        this.hostnameHashes = undefined;
        this.entityHashes = undefined;
        this._originalRequestDetails = _originalRequestDetails;
        this.id = requestId;
        this.tabId = tabId;
        this.type = type;
        this.url = url;
        this.hostname = hostname;
        this.domain = domain;
        this.sourceHostnameHashes =
            sourceHostname.length === 0
                ? dataView.EMPTY_UINT32_ARRAY
                : getHostnameHashesFromLabelsBackward(sourceHostname, sourceDomain);
        this.sourceEntityHashes =
            sourceHostname.length === 0
                ? dataView.EMPTY_UINT32_ARRAY
                : getEntityHashesFromLabelsBackward(sourceHostname, sourceDomain);
        // Decide on partiness
        this.isThirdParty = isThirdParty(hostname, domain, sourceHostname, sourceDomain, type);
        this.isFirstParty = !this.isThirdParty;
        // Check protocol
        this.isSupported = true;
        if (this.type === 'websocket' || this.url.startsWith('ws:') || this.url.startsWith('wss:')) {
            this.isHttp = false;
            this.isHttps = false;
            this.type = 'websocket';
            this.isSupported = true;
        }
        else if (this.url.startsWith('http:')) {
            this.isHttp = true;
            this.isHttps = false;
        }
        else if (this.url.startsWith('https:')) {
            this.isHttps = true;
            this.isHttp = false;
        }
        else if (this.url.startsWith('data:')) {
            this.isHttp = false;
            this.isHttps = false;
            // Only keep prefix of URL
            const indexOfComa = this.url.indexOf(',');
            if (indexOfComa !== -1) {
                this.url = this.url.slice(0, indexOfComa);
            }
        }
        else {
            this.isHttp = false;
            this.isHttps = false;
            this.isSupported = false;
        }
    }
    getHostnameHashes() {
        if (this.hostnameHashes === undefined) {
            this.hostnameHashes =
                this.hostname.length === 0
                    ? dataView.EMPTY_UINT32_ARRAY
                    : getHostnameHashesFromLabelsBackward(this.hostname, this.domain);
        }
        return this.hostnameHashes;
    }
    getEntityHashes() {
        if (this.entityHashes === undefined) {
            this.entityHashes =
                this.hostname.length === 0
                    ? dataView.EMPTY_UINT32_ARRAY
                    : getEntityHashesFromLabelsBackward(this.hostname, this.domain);
        }
        return this.entityHashes;
    }
    getTokens() {
        if (this.tokens === undefined) {
            tokensBuffer.TOKENS_BUFFER.reset();
            for (const hash of this.sourceHostnameHashes) {
                tokensBuffer.TOKENS_BUFFER.push(hash);
            }
            // Add token corresponding to request type
            tokensBuffer.TOKENS_BUFFER.push(NORMALIZED_TYPE_TOKEN[this.type]);
            utils.tokenizeNoSkipInPlace(this.url, tokensBuffer.TOKENS_BUFFER);
            this.tokens = tokensBuffer.TOKENS_BUFFER.slice();
        }
        return this.tokens;
    }
    isMainFrame() {
        return this.type === 'main_frame' || this.type === 'mainFrame';
    }
    isSubFrame() {
        return this.type === 'sub_frame' || this.type === 'subFrame';
    }
    /**
     * Calling this method will attempt to guess the type of a request based on
     * information found in `url` only. This can be useful to try and fine-tune
     * the type of a Request when it is not otherwise available or if it was
     * inferred as 'other'.
     */
    guessTypeOfRequest() {
        const currentType = this.type;
        this.type = guessUrlType(this.url);
        if (currentType !== this.type) {
            this.tokens = undefined;
        }
        return this.type;
    }
}
/**
 * Kept for backward compatibility. The recommended way is to call
 * `Request.fromRawDetails` directly.
 */
function makeRequest(details) {
    return Request.fromRawDetails(details);
}

exports.NORMALIZED_TYPE_TOKEN = NORMALIZED_TYPE_TOKEN;
exports.default = Request;
exports.getEntityHashesFromLabelsBackward = getEntityHashesFromLabelsBackward;
exports.getHashesFromLabelsBackward = getHashesFromLabelsBackward;
exports.getHostnameHashesFromLabelsBackward = getHostnameHashesFromLabelsBackward;
exports.getHostnameWithoutPublicSuffix = getHostnameWithoutPublicSuffix;
exports.hashHostnameBackward = hashHostnameBackward;
exports.makeRequest = makeRequest;
//# sourceMappingURL=request.cjs.map
