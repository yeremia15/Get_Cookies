{"version":3,"file":"cosmetic.cjs","sources":["../../../src/src/filters/cosmetic.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { classifySelector, SelectorType, parse as parseCssSelector, } from '@cliqz/adblocker-extended-selectors';\nimport { Domains } from '../engine/domains';\nimport { EMPTY_UINT32_ARRAY, sizeOfASCII, sizeOfCosmeticSelector, sizeOfUTF8, sizeOfRawCosmetic, } from '../data-view';\nimport { getHostnameHashesFromLabelsBackward, getEntityHashesFromLabelsBackward, } from '../request';\nimport { fastHash, fastHashBetween, fastStartsWithFrom, getBit, hasUnicode, setBit, tokenize, HASH_SEED, HASH_INTERNAL_MULT, } from '../utils';\nimport { extractHTMLSelectorFromRule } from '../html-filtering';\nconst EMPTY_TOKENS = [EMPTY_UINT32_ARRAY];\nexport const DEFAULT_HIDDING_STYLE = 'display: none !important;';\nconst REGEXP_UNICODE_COMMA = new RegExp(/\\\\u002C/, 'g');\nconst REGEXP_UNICODE_BACKSLASH = new RegExp(/\\\\u005C/, 'g');\nconst REGEXP_ESCAPED_COMMA = new RegExp(/\\\\,/, 'g');\n/**\n * Given a `selector` starting with either '#' or '.' check if what follows is\n * a simple CSS selector: /^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/\n */\nfunction isSimpleSelector(selector) {\n    for (let i = 1; i < selector.length; i += 1) {\n        const code = selector.charCodeAt(i);\n        if (!(code === 45 /* '-' */ ||\n            code === 95 /* '_' */ ||\n            (code >= 48 && code <= 57) /* [0-9] */ ||\n            (code >= 65 && code <= 90) /* [A-Z] */ ||\n            (code >= 97 && code <= 122)) /* [a-z] */) {\n            if (i < selector.length - 1) {\n                // Check if what follows is a ' >' or ' ~' or ' +', in which case we\n                // also consider it a simple selector and the token this filter can be\n                // indexed with is the first selector.\n                const nextCode = selector.charCodeAt(i + 1);\n                if (code === 91 /* '[' */ ||\n                    code === 46 /* '.' */ ||\n                    code === 58 /* ':' */ ||\n                    (code === 32 /* ' ' */ &&\n                        (nextCode === 62 /* '>' */ ||\n                            nextCode === 43 /* '+' */ ||\n                            nextCode === 126 /* '~' */ ||\n                            nextCode === 46 /* '.' */ ||\n                            nextCode === 35)) /* '#' */) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Given a `selector` starting with either 'a[' or '[', check if what follows\n * is a simple href attribute selector of the form: 'href^=' or 'href*='.\n */\nfunction isSimpleHrefSelector(selector, start) {\n    return (selector.startsWith('href^=\"', start) ||\n        selector.startsWith('href*=\"', start) ||\n        selector.startsWith('href=\"', start));\n}\n/**\n * Validate CSS selector. There is a fast path for simple selectors (e.g.: #foo\n * or .bar) which are the most common case. For complex ones, we rely on\n * `Element.matches` (if available).\n */\nconst isValidCss = (() => {\n    const div = typeof document !== 'undefined'\n        ? document.createElement('div')\n        : {\n            matches: () => {\n                /* noop */\n            },\n        };\n    const matches = (selector) => div.matches(selector);\n    const validSelectorRe = /^[#.]?[\\w-.]+$/;\n    return function isValidCssImpl(selector) {\n        if (validSelectorRe.test(selector)) {\n            return true;\n        }\n        try {\n            matches(selector);\n        }\n        catch (ex) {\n            return false;\n        }\n        return true;\n    };\n})();\nfunction computeFilterId(mask, selector, domains, style) {\n    let hash = (HASH_SEED * HASH_INTERNAL_MULT) ^ mask;\n    if (selector !== undefined) {\n        for (let i = 0; i < selector.length; i += 1) {\n            hash = (hash * HASH_INTERNAL_MULT) ^ selector.charCodeAt(i);\n        }\n    }\n    if (domains !== undefined) {\n        hash = domains.updateId(hash);\n    }\n    if (style !== undefined) {\n        for (let i = 0; i < style.length; i += 1) {\n            hash = (hash * HASH_INTERNAL_MULT) ^ style.charCodeAt(i);\n        }\n    }\n    return hash >>> 0;\n}\n/***************************************************************************\n *  Cosmetic filters parsing\n * ************************************************************************ */\nexport default class CosmeticFilter {\n    /**\n     * Given a line that we know contains a cosmetic filter, create a CosmeticFiler\n     * instance out of it. This function should be *very* efficient, as it will be\n     * used to parse tens of thousands of lines.\n     */\n    static parse(line, debug = false) {\n        const rawLine = line;\n        // Mask to store attributes. Each flag (unhide, scriptInject, etc.) takes\n        // only 1 bit at a specific offset defined in COSMETICS_MASK.\n        // cf: COSMETICS_MASK for the offset of each property\n        let mask = 0;\n        let selector;\n        let domains;\n        let style;\n        const sharpIndex = line.indexOf('#');\n        // Start parsing the line\n        const afterSharpIndex = sharpIndex + 1;\n        let suffixStartIndex = afterSharpIndex + 1;\n        // hostname1,hostname2#?#.selector\n        // hostname1,hostname2#@#.selector\n        //                    ^^ ^\n        //                    || |\n        //                    || suffixStartIndex\n        //                    |afterSharpIndex\n        //                    sharpIndex\n        // Check if unhide\n        if (line.length > afterSharpIndex) {\n            if (line[afterSharpIndex] === '@') {\n                mask = setBit(mask, 1 /* COSMETICS_MASK.unhide */);\n                suffixStartIndex += 1;\n            }\n            else if (line[afterSharpIndex] === '?') {\n                suffixStartIndex += 1;\n            }\n        }\n        if (suffixStartIndex >= line.length) {\n            return null;\n        }\n        // Parse hostnames and entitites as well as their negations.\n        //\n        // - ~hostname##.selector\n        // - hostname##.selector\n        // - entity.*##.selector\n        // - ~entity.*##.selector\n        //\n        // Each kind will have its own Uint32Array containing hashes, sorted by\n        // number of labels considered. This allows a compact representation of\n        // hostnames and fast matching without any string copy.\n        if (sharpIndex > 0) {\n            domains = Domains.parse(line.slice(0, sharpIndex).split(','), debug);\n        }\n        if (line.endsWith(':remove()')) {\n            // ##selector:remove()\n            mask = setBit(mask, 64 /* COSMETICS_MASK.remove */);\n            mask = setBit(mask, 128 /* COSMETICS_MASK.extended */);\n            line = line.slice(0, -9);\n        }\n        else if (line.length - suffixStartIndex >= 8 &&\n            line.endsWith(')') &&\n            line.indexOf(':style(', suffixStartIndex) !== -1) {\n            // ##selector:style(...)\n            const indexOfStyle = line.indexOf(':style(', suffixStartIndex);\n            style = line.slice(indexOfStyle + 7, -1);\n            line = line.slice(0, indexOfStyle);\n        }\n        // Deal with HTML filters\n        if (line.charCodeAt(suffixStartIndex) === 94 /* '^' */) {\n            if (fastStartsWithFrom(line, 'script:has-text(', suffixStartIndex + 1) === false ||\n                line.charCodeAt(line.length - 1) !== 41 /* ')' */) {\n                return null;\n            }\n            // NOTE: currently only ^script:has-text(...) is supported.\n            //\n            //   ^script:has-text(selector)\n            //   ^                         ^\n            //   |                         |\n            //   |                         |\n            //   |                         line.length\n            //   |\n            //   suffixStartIndex\n            //\n            selector = line.slice(suffixStartIndex, line.length);\n            if (extractHTMLSelectorFromRule(selector) === undefined) {\n                return null;\n            }\n        }\n        else if (line.length - suffixStartIndex > 4 &&\n            line.charCodeAt(suffixStartIndex) === 43 /* '+' */ &&\n            fastStartsWithFrom(line, '+js(', suffixStartIndex)) {\n            // Generic scriptlets are invalid, unless they are un-hide\n            if ((domains === undefined ||\n                (domains.hostnames === undefined && domains.entities === undefined)) &&\n                getBit(mask, 1 /* COSMETICS_MASK.unhide */) === false) {\n                return null;\n            }\n            mask = setBit(mask, 2 /* COSMETICS_MASK.scriptInject */);\n            selector = line.slice(suffixStartIndex + 4, line.length - 1);\n            // An empty scriptlet (i.e. '+js()') can be specified to cancel injections\n            // on a specific domain or globally. It does not make sense though to have\n            // an empty scriptlet without an exception (i.e. '#@#' is mandatory).\n            if (getBit(mask, 1 /* COSMETICS_MASK.unhide */) === false && selector.length === 0) {\n                return null;\n            }\n        }\n        else {\n            selector = line.slice(suffixStartIndex);\n            const selectorType = classifySelector(selector);\n            if (selectorType === SelectorType.Extended) {\n                mask = setBit(mask, 128 /* COSMETICS_MASK.extended */);\n            }\n            else if (selectorType === SelectorType.Invalid || !isValidCss(selector)) {\n                // console.error('Invalid', line);\n                // TODO - maybe perform `isValidCss` from the other module.\n                return null;\n            }\n        }\n        // Extended selectors should always be specific to some domain.\n        if (domains === undefined && getBit(mask, 128 /* COSMETICS_MASK.extended */) === true) {\n            return null;\n        }\n        if (selector !== undefined) {\n            // Check if unicode appears in selector\n            if (hasUnicode(selector)) {\n                mask = setBit(mask, 4 /* COSMETICS_MASK.isUnicode */);\n            }\n            // Classify selector\n            if (getBit(mask, 2 /* COSMETICS_MASK.scriptInject */) === false &&\n                getBit(mask, 64 /* COSMETICS_MASK.remove */) === false &&\n                getBit(mask, 128 /* COSMETICS_MASK.extended */) === false &&\n                selector.startsWith('^') === false) {\n                const c0 = selector.charCodeAt(0);\n                const c1 = selector.charCodeAt(1);\n                const c2 = selector.charCodeAt(2);\n                // Check if we have a specific case of simple selector (id, class or\n                // href) These are the most common filters and will benefit greatly from\n                // a custom dispatch mechanism.\n                if (getBit(mask, 2 /* COSMETICS_MASK.scriptInject */) === false) {\n                    if (c0 === 46 /* '.' */ && isSimpleSelector(selector)) {\n                        mask = setBit(mask, 8 /* COSMETICS_MASK.isClassSelector */);\n                    }\n                    else if (c0 === 35 /* '#' */ && isSimpleSelector(selector)) {\n                        mask = setBit(mask, 16 /* COSMETICS_MASK.isIdSelector */);\n                    }\n                    else if (c0 === 97 /* a */ &&\n                        c1 === 91 /* '[' */ &&\n                        c2 === 104 /* 'h' */ &&\n                        isSimpleHrefSelector(selector, 2)) {\n                        mask = setBit(mask, 32 /* COSMETICS_MASK.isHrefSelector */);\n                    }\n                    else if (c0 === 91 /* '[' */ &&\n                        c1 === 104 /* 'h' */ &&\n                        isSimpleHrefSelector(selector, 1)) {\n                        mask = setBit(mask, 32 /* COSMETICS_MASK.isHrefSelector */);\n                    }\n                }\n            }\n        }\n        return new CosmeticFilter({\n            mask,\n            rawLine: debug === true ? rawLine : undefined,\n            selector,\n            style,\n            domains,\n        });\n    }\n    /**\n     * Deserialize cosmetic filters. The code accessing the buffer should be\n     * symetrical to the one in `serializeCosmeticFilter`.\n     */\n    static deserialize(buffer) {\n        const mask = buffer.getUint8();\n        const isUnicode = getBit(mask, 4 /* COSMETICS_MASK.isUnicode */);\n        const optionalParts = buffer.getUint8();\n        const selector = isUnicode ? buffer.getUTF8() : buffer.getCosmeticSelector();\n        // The order of these fields should be the same as when we serialize them.\n        return new CosmeticFilter({\n            // Mandatory fields\n            mask,\n            selector,\n            // Optional fields\n            domains: (optionalParts & 1) === 1 ? Domains.deserialize(buffer) : undefined,\n            rawLine: (optionalParts & 2) === 2 ? buffer.getRawCosmetic() : undefined,\n            style: (optionalParts & 4) === 4 ? buffer.getASCII() : undefined,\n        });\n    }\n    constructor({ mask, selector, domains, rawLine, style, }) {\n        this.mask = mask;\n        this.selector = selector;\n        this.domains = domains;\n        this.style = style;\n        this.id = undefined;\n        this.rawLine = rawLine;\n    }\n    isCosmeticFilter() {\n        return true;\n    }\n    isNetworkFilter() {\n        return false;\n    }\n    /**\n     * The format of a cosmetic filter is:\n     *\n     * | mask | selector length | selector... | hostnames length | hostnames...\n     *   32     16                              16\n     *\n     * The header (mask) is 32 bits, then we have a total of 32 bits to store the\n     * length of `selector` and `hostnames` (16 bits each).\n     *\n     * Improvements similar to the onces mentioned in `serializeNetworkFilters`\n     * could be applied here, to get a more compact representation.\n     */\n    serialize(buffer) {\n        // Mandatory fields\n        buffer.pushUint8(this.mask);\n        const index = buffer.getPos();\n        buffer.pushUint8(0);\n        if (this.isUnicode()) {\n            buffer.pushUTF8(this.selector);\n        }\n        else {\n            buffer.pushCosmeticSelector(this.selector);\n        }\n        // This bit-mask indicates which optional parts of the filter were serialized.\n        let optionalParts = 0;\n        if (this.domains !== undefined) {\n            optionalParts |= 1;\n            this.domains.serialize(buffer);\n        }\n        if (this.rawLine !== undefined) {\n            optionalParts |= 2;\n            buffer.pushRawCosmetic(this.rawLine);\n        }\n        if (this.style !== undefined) {\n            optionalParts |= 4;\n            buffer.pushASCII(this.style);\n        }\n        buffer.setByte(index, optionalParts);\n    }\n    /**\n     * Return an estimation of the size (in bytes) needed to persist this filter\n     * in a DataView. This does not need to be 100% accurate but should be an\n     * upper-bound. It should also be as fast as possible.\n     */\n    getSerializedSize(compression) {\n        let estimate = 1 + 1; // mask (1 byte) + optional parts (1 byte)\n        if (this.isUnicode()) {\n            estimate += sizeOfUTF8(this.selector);\n        }\n        else {\n            estimate += sizeOfCosmeticSelector(this.selector, compression);\n        }\n        if (this.domains !== undefined) {\n            estimate += this.domains.getSerializedSize();\n        }\n        if (this.rawLine !== undefined) {\n            estimate += sizeOfRawCosmetic(this.rawLine, compression);\n        }\n        if (this.style !== undefined) {\n            estimate += sizeOfASCII(this.style);\n        }\n        return estimate;\n    }\n    /**\n     * Create a more human-readable version of this filter. It is mainly used for\n     * debugging purpose, as it will expand the values stored in the bit mask.\n     */\n    toString() {\n        if (this.rawLine !== undefined) {\n            return this.rawLine;\n        }\n        let filter = '';\n        if (this.domains !== undefined) {\n            if (this.domains.parts !== undefined) {\n                filter += this.domains.parts;\n            }\n            else {\n                filter += '<hostnames>';\n            }\n        }\n        if (this.isUnhide()) {\n            filter += '#@#';\n        }\n        else {\n            filter += '##';\n        }\n        if (this.isScriptInject()) {\n            filter += '+js(';\n            filter += this.selector;\n            filter += ')';\n        }\n        else {\n            filter += this.selector;\n        }\n        return filter;\n    }\n    match(hostname, domain) {\n        // Not constraint on hostname, match is true\n        if (this.hasHostnameConstraint() === false) {\n            return true;\n        }\n        // No `hostname` available but this filter has some constraints on hostname.\n        if (!hostname && this.hasHostnameConstraint()) {\n            return false;\n        }\n        if (this.domains !== undefined) {\n            // TODO - this hashing could be re-used between cosmetics by using an\n            // abstraction like `Request` (similar to network filters matching).\n            // Maybe could we reuse `Request` directly without any change?\n            return this.domains.match(hostname.length === 0\n                ? EMPTY_UINT32_ARRAY\n                : getHostnameHashesFromLabelsBackward(hostname, domain), hostname.length === 0\n                ? EMPTY_UINT32_ARRAY\n                : getEntityHashesFromLabelsBackward(hostname, domain));\n        }\n        return true;\n    }\n    /**\n     * Get tokens for this filter. It can be indexed multiple times if multiple\n     * hostnames are specified (e.g.: host1,host2##.selector).\n     */\n    getTokens() {\n        const tokens = [];\n        // Note, we do not need to use negated domains or entities as tokens here\n        // since they will by definition not match on their own, unless accompanied\n        // by a domain or entity. Instead, they are handled in\n        // `CosmeticFilterBucket.getCosmeticsFilters(...)`.\n        if (this.domains !== undefined) {\n            const { hostnames, entities } = this.domains;\n            if (hostnames !== undefined) {\n                for (const hostname of hostnames) {\n                    tokens.push(new Uint32Array([hostname]));\n                }\n            }\n            if (entities !== undefined) {\n                for (const entity of entities) {\n                    tokens.push(new Uint32Array([entity]));\n                }\n            }\n        }\n        // Here we only take selector into account if the filter is not unHide.\n        if (tokens.length === 0 && this.isUnhide() === false) {\n            if (this.isIdSelector() || this.isClassSelector()) {\n                // Here we try to identify the end of selector si that we can extract a\n                // valid token out of it. In all these examples, 'selector' is our\n                // token:\n                //\n                //   .selector[...]\n                //   #selector[...]\n                //   #selector ~ foo\n                //   .selector:not(...)\n                //   .selector.foo\n                //\n                // We now try to identify the first valid end of selector which will\n                // also be the end of our token: space, bracket, colon, dot.\n                let endOfSelector = 1;\n                const selector = this.selector;\n                for (; endOfSelector < selector.length; endOfSelector += 1) {\n                    const code = selector.charCodeAt(endOfSelector);\n                    if (code === 32 /* ' ' */ ||\n                        code === 46 /* '.' */ ||\n                        code === 58 /* ':' */ ||\n                        code === 91 /* '[' */) {\n                        break;\n                    }\n                }\n                const arr = new Uint32Array(1);\n                arr[0] = fastHashBetween(selector, 1, endOfSelector);\n                tokens.push(arr);\n            }\n            else if (this.isHrefSelector() === true) {\n                const selector = this.getSelector();\n                // Locate 'href' in selector\n                let hrefIndex = selector.indexOf('href');\n                if (hrefIndex === -1) {\n                    return EMPTY_TOKENS;\n                }\n                hrefIndex += 4;\n                // Tokenize optimally depending on the kind of selector: 'href=',\n                // 'href*=', 'href^='.\n                let skipFirstToken = false;\n                let skipLastToken = true;\n                if (selector.charCodeAt(hrefIndex) === 42 /* '*' */) {\n                    // skip: '*'\n                    skipFirstToken = true;\n                    hrefIndex += 1;\n                }\n                else if (selector.charCodeAt(hrefIndex) === 94 /* '^' */) {\n                    // skip: '^'\n                    hrefIndex += 1;\n                }\n                else {\n                    skipLastToken = false;\n                }\n                hrefIndex += 2; // skip:  '=\"'\n                // Locate end of href\n                const hrefEnd = selector.indexOf('\"', hrefIndex);\n                if (hrefEnd === -1) {\n                    // That cannot happen unless the filter is not well-formed. In this\n                    // case, we just return no tokens, which will result in this filter\n                    // ending up in the \"wildcard\" bucket of the index.\n                    return EMPTY_TOKENS;\n                }\n                tokens.push(tokenize(this.selector.slice(hrefIndex, hrefEnd), skipFirstToken, skipLastToken));\n            }\n        }\n        if (tokens.length === 0) {\n            return EMPTY_TOKENS;\n        }\n        return tokens;\n    }\n    parseScript() {\n        const selector = this.getSelector();\n        if (selector.length === 0) {\n            return undefined;\n        }\n        const parts = [];\n        let index = 0;\n        let lastComaIndex = -1;\n        let inDoubleQuotes = false;\n        let inSingleQuotes = false;\n        let inRegexp = false;\n        let objectNesting = 0;\n        let lastCharIsBackslash = false;\n        let inArgument = false;\n        for (; index < selector.length; index += 1) {\n            const char = selector[index];\n            if (lastCharIsBackslash === false) {\n                if (inDoubleQuotes === true) {\n                    if (char === '\"') {\n                        inDoubleQuotes = false;\n                    }\n                }\n                else if (inSingleQuotes === true) {\n                    if (char === \"'\") {\n                        inSingleQuotes = false;\n                    }\n                }\n                else if (objectNesting !== 0) {\n                    if (char === '{') {\n                        objectNesting += 1;\n                    }\n                    else if (char === '}') {\n                        objectNesting -= 1;\n                    }\n                    else if (char === '\"') {\n                        inDoubleQuotes = true;\n                    }\n                    else if (char === \"'\") {\n                        inSingleQuotes = true;\n                    }\n                }\n                else if (inRegexp === true) {\n                    if (char === '/') {\n                        inRegexp = false;\n                    }\n                }\n                else {\n                    if (inArgument === false) {\n                        if (char === ' ') {\n                            // ignore\n                        }\n                        else if (char === '\"' && selector.indexOf('\"', index + 1) > 0) {\n                            inDoubleQuotes = true;\n                        }\n                        else if (char === \"'\" && selector.indexOf(\"'\", index + 1) > 0) {\n                            inSingleQuotes = true;\n                        }\n                        else if (char === '{' && selector.indexOf('}', index + 1) > 0) {\n                            objectNesting += 1;\n                        }\n                        else if (char === '/' && selector.indexOf('/', index + 1) > 0) {\n                            inRegexp = true;\n                        }\n                        else {\n                            inArgument = true;\n                        }\n                    }\n                    if (char === ',') {\n                        parts.push(selector.slice(lastComaIndex + 1, index).trim());\n                        lastComaIndex = index;\n                        inArgument = false;\n                    }\n                }\n            }\n            lastCharIsBackslash = char === '\\\\';\n        }\n        parts.push(selector.slice(lastComaIndex + 1).trim());\n        if (parts.length === 0) {\n            return undefined;\n        }\n        const args = parts\n            .slice(1)\n            .map((part) => {\n            if ((part.startsWith(`'`) && part.endsWith(`'`)) ||\n                (part.startsWith(`\"`) && part.endsWith(`\"`))) {\n                return part.substring(1, part.length - 1);\n            }\n            return part;\n        })\n            .map((part) => part\n            .replace(REGEXP_UNICODE_COMMA, ',')\n            .replace(REGEXP_UNICODE_BACKSLASH, '\\\\')\n            .replace(REGEXP_ESCAPED_COMMA, ','));\n        return { name: parts[0], args };\n    }\n    getScript(js) {\n        const parsed = this.parseScript();\n        if (parsed === undefined) {\n            return undefined;\n        }\n        const { name, args } = parsed;\n        let script = js.get(name);\n        if (script !== undefined) {\n            for (let i = 0; i < args.length; i += 1) {\n                // escape some characters so they wont get evaluated with escape characters during script injection\n                const arg = args[i].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                script = script.replace(`{{${i + 1}}}`, arg);\n            }\n            return script;\n        } // TODO - else throw an exception?\n        return undefined;\n    }\n    hasHostnameConstraint() {\n        return this.domains !== undefined;\n    }\n    getId() {\n        if (this.id === undefined) {\n            this.id = computeFilterId(this.mask, this.selector, this.domains, this.style);\n        }\n        return this.id;\n    }\n    hasCustomStyle() {\n        return this.style !== undefined;\n    }\n    getStyle() {\n        return this.style || DEFAULT_HIDDING_STYLE;\n    }\n    getStyleAttributeHash() {\n        return `s${fastHash(this.getStyle())}`;\n    }\n    getSelector() {\n        return this.selector;\n    }\n    getSelectorAST() {\n        return parseCssSelector(this.getSelector());\n    }\n    getExtendedSelector() {\n        return extractHTMLSelectorFromRule(this.selector);\n    }\n    isExtended() {\n        return getBit(this.mask, 128 /* COSMETICS_MASK.extended */);\n    }\n    isRemove() {\n        return getBit(this.mask, 64 /* COSMETICS_MASK.remove */);\n    }\n    isUnhide() {\n        return getBit(this.mask, 1 /* COSMETICS_MASK.unhide */);\n    }\n    isScriptInject() {\n        return getBit(this.mask, 2 /* COSMETICS_MASK.scriptInject */);\n    }\n    isCSS() {\n        return this.isScriptInject() === false;\n    }\n    isIdSelector() {\n        return getBit(this.mask, 16 /* COSMETICS_MASK.isIdSelector */);\n    }\n    isClassSelector() {\n        return getBit(this.mask, 8 /* COSMETICS_MASK.isClassSelector */);\n    }\n    isHrefSelector() {\n        return getBit(this.mask, 32 /* COSMETICS_MASK.isHrefSelector */);\n    }\n    isUnicode() {\n        return getBit(this.mask, 4 /* COSMETICS_MASK.isUnicode */);\n    }\n    isHtmlFiltering() {\n        return this.getSelector().startsWith('^');\n    }\n    // A generic hide cosmetic filter is one that:\n    //\n    // * Do not have a domain specified. \"Hide this element on all domains\"\n    // * Have only domain exceptions specified. \"Hide this element on all domains except example.com\"\n    //\n    // For example: ~example.com##.ad  is a generic filter as well!\n    isGenericHide() {\n        var _a, _b;\n        return ((_a = this === null || this === void 0 ? void 0 : this.domains) === null || _a === void 0 ? void 0 : _a.hostnames) === undefined && ((_b = this === null || this === void 0 ? void 0 : this.domains) === null || _b === void 0 ? void 0 : _b.entities) === undefined;\n    }\n}\n//# sourceMappingURL=cosmetic.js.map"],"names":["EMPTY_UINT32_ARRAY","HASH_SEED","HASH_INTERNAL_MULT","domains","setBit","Domains","fastStartsWithFrom","extractHTMLSelectorFromRule","getBit","classifySelector","SelectorType","hasUnicode","sizeOfUTF8","sizeOfCosmeticSelector","sizeOfRawCosmetic","sizeOfASCII","getHostnameHashesFromLabelsBackward","getEntityHashesFromLabelsBackward","fastHashBetween","tokenize","fastHash","parseCssSelector"],"mappings":"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"}