{"version":3,"file":"map.cjs","sources":["../../../src/src/engine/map.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { StaticDataView, sizeOfBytes, EMPTY_UINT32_ARRAY } from '../data-view';\nimport { nextPow2 } from './reverse-index';\nconst EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;\n/**\n * This is a simpler version of reverse-index data structure which implements\n * a simple Map-like class, backed by compact typed arrays. This means that\n * the structure can be serialized to a typed array very quickly and loaded\n * back instantly.\n */\nexport class CompactMap {\n    static deserialize(buffer, deserialize) {\n        const tokensLookupIndexSize = buffer.getUint32();\n        const bucketsIndexSize = buffer.getUint32();\n        const numberOfValues = buffer.getUint32();\n        // Alignement to 4 bytes is important here since `view` (Uint8Array) can\n        // appear at any offset of `buffer`. But to be sure we can read back\n        // Uint32Array directly from raw buffer, the alignement has to be a\n        // multiple of 4. The same alignement is taken care of in `serialize`.\n        const view = StaticDataView.fromUint8Array(buffer.getBytes(true /* align */), {\n            enableCompression: false,\n        });\n        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);\n        const valuesIndexStart = view.pos;\n        view.seekZero(); // not strictly needed but make sure reverse index can be compared with deep equal\n        return new CompactMap({\n            deserialize,\n            // Left empty on purpose since we don't need these to deserialize (all\n            // the data is already in the serialized data).\n            values: [],\n            getKeys: () => [],\n            getSerializedSize: () => 0,\n            serialize: () => {\n                /* Empty */\n            },\n        }).updateInternals({\n            bucketsIndex,\n            valuesIndexStart,\n            numberOfValues,\n            tokensLookupIndex,\n            view,\n        });\n    }\n    constructor({ serialize, deserialize, getKeys, getSerializedSize, values, }) {\n        // In-memory cache used to keep track of metadata which has already been\n        // loaded from the compact representation (i.e.: this.view). It is not\n        // strictly necessary but will speed-up retrival of popular patterns\n        // (since we do not have to perform the lookup again).\n        this.cache = new Map();\n        this.bucketsIndex = EMPTY_UINT32_ARRAY;\n        this.tokensLookupIndex = EMPTY_UINT32_ARRAY;\n        this.valuesIndexStart = 0;\n        this.numberOfValues = 0;\n        this.view = StaticDataView.empty({ enableCompression: false });\n        this.deserializeValue = deserialize;\n        if (values.length !== 0) {\n            const patternsKeys = [];\n            // Keep track of the final size of the buckets index. `bucketsIndexSize`\n            // is the number of indexed values, multiplied by 2 (since we store both\n            // the `key` a value is indexed with and the index of the value itself).\n            let bucketsIndexSize = 0;\n            // Create a list of all values which will be part of the map. This means\n            // computing an estimation of the buffer size needed to store this index.\n            let estimatedBufferSize = 0;\n            for (const value of values) {\n                estimatedBufferSize += getSerializedSize(value);\n            }\n            // No values given; reset to empty index and abort.\n            if (values.length === 0) {\n                this.updateInternals({\n                    bucketsIndex: EMPTY_UINT32_ARRAY,\n                    valuesIndexStart: 0,\n                    numberOfValues: 0,\n                    tokensLookupIndex: EMPTY_UINT32_ARRAY,\n                    view: StaticDataView.empty({ enableCompression: false }),\n                });\n                return;\n            }\n            for (const value of values) {\n                // Get keys from `value` and store the result in `patternsKeys` which\n                // will be used in the next step to select the best key for each value.\n                const keys = getKeys(value);\n                patternsKeys.push(keys);\n                bucketsIndexSize += 2 * keys.length; // key + value index\n            }\n            // Add size of bucketsIndex to total size (x4 because these are 32 bits numbers)\n            estimatedBufferSize += bucketsIndexSize * 4;\n            // Prepare \"tokens index\" (see documentation in constructor of `ReverseIndex` class).\n            const tokensLookupIndexSize = Math.max(2, nextPow2(values.length));\n            const mask = tokensLookupIndexSize - 1;\n            const suffixes = [];\n            for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n                suffixes.push([]);\n            }\n            // Add size of tokensLookupIndex to total size (x4 because these are 32 bits numbers)\n            estimatedBufferSize += tokensLookupIndexSize * 4;\n            // At this point we know the number of bytes needed for the compact\n            // representation of this map (\"tokens index\" + \"buckets index\" +\n            // \"values index\"). We allocate it at once and proceed with populating it.\n            const buffer = StaticDataView.allocate(estimatedBufferSize, { enableCompression: false });\n            const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);\n            const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);\n            const valuesIndexStart = buffer.getPos();\n            // For each value, find the best token (least seen) based on histogram.\n            // Since we are iterating again on the values, we populate \"values index\"\n            // in the same loop and keep track of their indices so that we can later\n            // populate \"buckets index\".\n            for (let i = 0; i < patternsKeys.length; i += 1) {\n                const value = values[i];\n                const keys = patternsKeys[i];\n                // Serialize this value and keep track of its index in the byte array;\n                // it will be used in \"buckets index\" to point to this value.\n                const valueIndex = buffer.pos;\n                serialize(value, buffer);\n                for (const key of keys) {\n                    // `key & mask` represents the N last bits of `key`. We group all\n                    // values indexed with the same `key` sharing the same N bits.\n                    suffixes[key & mask].push([key, valueIndex]);\n                }\n            }\n            // Populate \"tokens index\" and \"buckets index\" based on keys for each value.\n            let indexInBucketsIndex = 0;\n            for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n                const valuesForMask = suffixes[i];\n                tokensLookupIndex[i] = indexInBucketsIndex;\n                for (const [token, valueIndex] of valuesForMask) {\n                    bucketsIndex[indexInBucketsIndex++] = token;\n                    bucketsIndex[indexInBucketsIndex++] = valueIndex;\n                }\n            }\n            // Update internals\n            this.updateInternals({\n                bucketsIndex,\n                valuesIndexStart,\n                numberOfValues: patternsKeys.length,\n                tokensLookupIndex,\n                view: buffer,\n            });\n        }\n    }\n    updateInternals({ bucketsIndex, valuesIndexStart, numberOfValues, tokensLookupIndex, view, }) {\n        this.bucketsIndex = bucketsIndex;\n        this.valuesIndexStart = valuesIndexStart;\n        this.numberOfValues = numberOfValues;\n        this.tokensLookupIndex = tokensLookupIndex;\n        this.view = view;\n        view.seekZero();\n        return this;\n    }\n    getValues() {\n        const values = [];\n        if (this.numberOfValues === 0) {\n            return values;\n        }\n        // set view cursor at the start of \"values index\"\n        this.view.setPos(this.valuesIndexStart);\n        for (let i = 0; i < this.numberOfValues; i += 1) {\n            values.push(this.deserializeValue(this.view));\n        }\n        this.view.seekZero();\n        return values;\n    }\n    /**\n     * Estimate the number of bytes needed to serialize this instance of `Map`.\n     */\n    getSerializedSize() {\n        // 12 = 4 bytes (tokensLookupIndex.length) + 4 bytes (bucketsIndex.length) + 4 bytes (numberOfValues)\n        return 12 + sizeOfBytes(this.view.buffer, true /* align */);\n    }\n    /**\n     * Dump this index to `buffer`.\n     */\n    serialize(buffer) {\n        buffer.pushUint32(this.tokensLookupIndex.length);\n        buffer.pushUint32(this.bucketsIndex.length);\n        buffer.pushUint32(this.numberOfValues);\n        // Aligmenent is crucial here, see comment in `deserialize` for more info.\n        buffer.pushBytes(this.view.buffer, true /* align */);\n    }\n    get(key) {\n        const cachedValues = this.cache.get(key);\n        if (cachedValues !== undefined) {\n            return cachedValues;\n        }\n        const offset = key & (this.tokensLookupIndex.length - 1);\n        const startOfBucket = this.tokensLookupIndex[offset];\n        // We do not have any values for this token\n        if (startOfBucket === EMPTY_BUCKET) {\n            return [];\n        }\n        // Since we do not store explicitly the number of values in each\n        // \"bucket\", we check the index of the next one and use it to infer the\n        // number of values (each value being stored as a token + index to the\n        // \"values store\")\n        const endOfBucket = offset === this.tokensLookupIndex.length - 1\n            ? this.bucketsIndex.length\n            : this.tokensLookupIndex[offset + 1];\n        // Get indices of values indexed with `token`, if any.\n        const valuesIndices = [];\n        for (let i = startOfBucket; i < endOfBucket; i += 2) {\n            const currentToken = this.bucketsIndex[i];\n            if (currentToken === key) {\n                valuesIndices.push(this.bucketsIndex[i + 1]);\n            }\n        }\n        // No value indexed with `token`.\n        if (valuesIndices.length === 0) {\n            return []; // continue looking for a match\n        }\n        // If we have values for `token` then deserialize values in memory and\n        // create a `Bucket` instance to hold them for future access.\n        const values = [];\n        const view = this.view;\n        for (let i = 0; i < valuesIndices.length; i += 1) {\n            view.setPos(valuesIndices[i]);\n            values.push(this.deserializeValue(view));\n        }\n        this.cache.set(key, values);\n        return values;\n    }\n}\n//# sourceMappingURL=map.js.map"],"names":["StaticDataView","EMPTY_UINT32_ARRAY","nextPow2","sizeOfBytes"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,MAAM,YAAY,GAAG,MAAM,CAAC,gBAAgB,KAAK,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,UAAU,CAAC;AACxB,IAAI,OAAO,WAAW,CAAC,MAAM,EAAE,WAAW,EAAE;AAC5C,QAAQ,MAAM,qBAAqB,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;AACzD,QAAQ,MAAM,gBAAgB,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;AACpD,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;AAClD;AACA;AACA;AACA;AACA,QAAQ,MAAM,IAAI,GAAGA,uBAAc,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,aAAa,EAAE;AACtF,YAAY,iBAAiB,EAAE,KAAK;AACpC,SAAS,CAAC,CAAC;AACX,QAAQ,MAAM,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,CAAC;AACjF,QAAQ,MAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;AACvE,QAAQ,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC;AAC1C,QAAQ,IAAI,CAAC,QAAQ,EAAE,CAAC;AACxB,QAAQ,OAAO,IAAI,UAAU,CAAC;AAC9B,YAAY,WAAW;AACvB;AACA;AACA,YAAY,MAAM,EAAE,EAAE;AACtB,YAAY,OAAO,EAAE,MAAM,EAAE;AAC7B,YAAY,iBAAiB,EAAE,MAAM,CAAC;AACtC,YAAY,SAAS,EAAE,MAAM;AAC7B;AACA,aAAa;AACb,SAAS,CAAC,CAAC,eAAe,CAAC;AAC3B,YAAY,YAAY;AACxB,YAAY,gBAAgB;AAC5B,YAAY,cAAc;AAC1B,YAAY,iBAAiB;AAC7B,YAAY,IAAI;AAChB,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,WAAW,CAAC,EAAE,SAAS,EAAE,WAAW,EAAE,OAAO,EAAE,iBAAiB,EAAE,MAAM,GAAG,EAAE;AACjF;AACA;AACA;AACA;AACA,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,EAAE,CAAC;AAC/B,QAAQ,IAAI,CAAC,YAAY,GAAGC,2BAAkB,CAAC;AAC/C,QAAQ,IAAI,CAAC,iBAAiB,GAAGA,2BAAkB,CAAC;AACpD,QAAQ,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;AAClC,QAAQ,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;AAChC,QAAQ,IAAI,CAAC,IAAI,GAAGD,uBAAc,CAAC,KAAK,CAAC,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;AACvE,QAAQ,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC;AAC5C,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACjC,YAAY,MAAM,YAAY,GAAG,EAAE,CAAC;AACpC;AACA;AACA;AACA,YAAY,IAAI,gBAAgB,GAAG,CAAC,CAAC;AACrC;AACA;AACA,YAAY,IAAI,mBAAmB,GAAG,CAAC,CAAC;AACxC,YAAY,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;AACxC,gBAAgB,mBAAmB,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAC;AAChE,aAAa;AACb;AACA,YAAY,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACrC,gBAAgB,IAAI,CAAC,eAAe,CAAC;AACrC,oBAAoB,YAAY,EAAEC,2BAAkB;AACpD,oBAAoB,gBAAgB,EAAE,CAAC;AACvC,oBAAoB,cAAc,EAAE,CAAC;AACrC,oBAAoB,iBAAiB,EAAEA,2BAAkB;AACzD,oBAAoB,IAAI,EAAED,uBAAc,CAAC,KAAK,CAAC,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC;AAC5E,iBAAiB,CAAC,CAAC;AACnB,gBAAgB,OAAO;AACvB,aAAa;AACb,YAAY,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;AACxC;AACA;AACA,gBAAgB,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;AAC5C,gBAAgB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACxC,gBAAgB,gBAAgB,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;AACpD,aAAa;AACb;AACA,YAAY,mBAAmB,IAAI,gBAAgB,GAAG,CAAC,CAAC;AACxD;AACA,YAAY,MAAM,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAEE,qBAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC/E,YAAY,MAAM,IAAI,GAAG,qBAAqB,GAAG,CAAC,CAAC;AACnD,YAAY,MAAM,QAAQ,GAAG,EAAE,CAAC;AAChC,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,EAAE,CAAC,IAAI,CAAC,EAAE;AAC/D,gBAAgB,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AAClC,aAAa;AACb;AACA,YAAY,mBAAmB,IAAI,qBAAqB,GAAG,CAAC,CAAC;AAC7D;AACA;AACA;AACA,YAAY,MAAM,MAAM,GAAGF,uBAAc,CAAC,QAAQ,CAAC,mBAAmB,EAAE,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;AACtG,YAAY,MAAM,iBAAiB,GAAG,MAAM,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,CAAC;AACvF,YAAY,MAAM,YAAY,GAAG,MAAM,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;AAC7E,YAAY,MAAM,gBAAgB,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;AACrD;AACA;AACA;AACA;AACA,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;AAC7D,gBAAgB,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACxC,gBAAgB,MAAM,IAAI,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;AAC7C;AACA;AACA,gBAAgB,MAAM,UAAU,GAAG,MAAM,CAAC,GAAG,CAAC;AAC9C,gBAAgB,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACzC,gBAAgB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AACxC;AACA;AACA,oBAAoB,QAAQ,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC;AACjE,iBAAiB;AACjB,aAAa;AACb;AACA,YAAY,IAAI,mBAAmB,GAAG,CAAC,CAAC;AACxC,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,EAAE,CAAC,IAAI,CAAC,EAAE;AAC/D,gBAAgB,MAAM,aAAa,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAClD,gBAAgB,iBAAiB,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC;AAC3D,gBAAgB,KAAK,MAAM,CAAC,KAAK,EAAE,UAAU,CAAC,IAAI,aAAa,EAAE;AACjE,oBAAoB,YAAY,CAAC,mBAAmB,EAAE,CAAC,GAAG,KAAK,CAAC;AAChE,oBAAoB,YAAY,CAAC,mBAAmB,EAAE,CAAC,GAAG,UAAU,CAAC;AACrE,iBAAiB;AACjB,aAAa;AACb;AACA,YAAY,IAAI,CAAC,eAAe,CAAC;AACjC,gBAAgB,YAAY;AAC5B,gBAAgB,gBAAgB;AAChC,gBAAgB,cAAc,EAAE,YAAY,CAAC,MAAM;AACnD,gBAAgB,iBAAiB;AACjC,gBAAgB,IAAI,EAAE,MAAM;AAC5B,aAAa,CAAC,CAAC;AACf,SAAS;AACT,KAAK;AACL,IAAI,eAAe,CAAC,EAAE,YAAY,EAAE,gBAAgB,EAAE,cAAc,EAAE,iBAAiB,EAAE,IAAI,GAAG,EAAE;AAClG,QAAQ,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;AACzC,QAAQ,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;AACjD,QAAQ,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;AAC7C,QAAQ,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AACnD,QAAQ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACzB,QAAQ,IAAI,CAAC,QAAQ,EAAE,CAAC;AACxB,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,SAAS,GAAG;AAChB,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,IAAI,IAAI,CAAC,cAAc,KAAK,CAAC,EAAE;AACvC,YAAY,OAAO,MAAM,CAAC;AAC1B,SAAS;AACT;AACA,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;AAChD,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,EAAE;AACzD,YAAY,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAC1D,SAAS;AACT,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;AAC7B,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL;AACA;AACA;AACA,IAAI,iBAAiB,GAAG;AACxB;AACA,QAAQ,OAAO,EAAE,GAAGG,oBAAW,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,aAAa,CAAC;AACpE,KAAK;AACL;AACA;AACA;AACA,IAAI,SAAS,CAAC,MAAM,EAAE;AACtB,QAAQ,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;AACzD,QAAQ,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;AACpD,QAAQ,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAC/C;AACA,QAAQ,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,aAAa,CAAC;AAC7D,KAAK;AACL,IAAI,GAAG,CAAC,GAAG,EAAE;AACb,QAAQ,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACjD,QAAQ,IAAI,YAAY,KAAK,SAAS,EAAE;AACxC,YAAY,OAAO,YAAY,CAAC;AAChC,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,GAAG,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACjE,QAAQ,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;AAC7D;AACA,QAAQ,IAAI,aAAa,KAAK,YAAY,EAAE;AAC5C,YAAY,OAAO,EAAE,CAAC;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,MAAM,WAAW,GAAG,MAAM,KAAK,IAAI,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC;AACxE,cAAc,IAAI,CAAC,YAAY,CAAC,MAAM;AACtC,cAAc,IAAI,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACjD;AACA,QAAQ,MAAM,aAAa,GAAG,EAAE,CAAC;AACjC,QAAQ,KAAK,IAAI,CAAC,GAAG,aAAa,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,IAAI,CAAC,EAAE;AAC7D,YAAY,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;AACtD,YAAY,IAAI,YAAY,KAAK,GAAG,EAAE;AACtC,gBAAgB,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7D,aAAa;AACb,SAAS;AACT;AACA,QAAQ,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;AACxC,YAAY,OAAO,EAAE,CAAC;AACtB,SAAS;AACT;AACA;AACA,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AAC/B,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;AAC1D,YAAY,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,YAAY,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;AACrD,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AACpC,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL;;;;"}