{"version":3,"file":"reverse-index.cjs","sources":["../../../src/src/engine/reverse-index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { StaticDataView, EMPTY_UINT32_ARRAY, sizeOfBytes } from '../data-view';\n// https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\nexport function nextPow2(v) {\n    v--;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v++;\n    return v;\n}\n/**\n * Generate unique IDs for requests, which is used to avoid matching the same\n * buckets multiple times on the same request (which can happen if a token\n * appears more than once in a URL).\n */\nlet UID = 1;\nfunction getNextId() {\n    const id = UID;\n    UID = (UID + 1) % 1000000000;\n    return id;\n}\nconst EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;\n/**\n * The ReverseIndex is an accelerating data structure which allows finding a\n * subset of the filters given a list of tokens seen in a URL. It is the core\n * of the adblocker's matching capabilities and speed.\n *\n * It has mainly two caracteristics:\n * 1. It is very compact and is able to load fast.\n * 2. It is *very fast* in finding potential candidates.\n *\n * Conceptually, the reverse index dispatches filters in \"buckets\" (an array of\n * one or more filters). Filters living in the same bucket are guaranteed to\n * share at least one of their tokens (appearing in the pattern). For example:\n *\n *   - Bucket 1 (ads):\n *       - /ads.js\n *       - /script/ads/tracking.js\n *       - /ads/\n *   - Bucket 2 (tracking)\n *       - /tracking.js\n *       - ||tracking.com/cdn\n *\n * We see that filters in \"Bucket 1\" are indexed using the token \"ads\" and\n * \"Bucket 2\" using token \"tracking\".\n *\n * This property allows to quickly discard most of the filters when we match a\n * URL. To achieve this, the URL is tokenized in the same way filters are\n * tokenized and for each token, we check if there are some filters available.\n *\n * For example:\n *\n *  URL \"https://tracking.com/\" has the following tokens: \"https\", \"tracking\"\n *  and \"com\". We immediatly see that we only check the two filters in the\n *  \"tracking\" bucket since they are the only ones having a common token with\n *  the URL.\n *\n * How do we pick the token for each filter?\n * =========================================\n *\n * Each filter is only indexed *once*, which means that we need to pick one of\n * the tokens appearing in the pattern. We choose the token such that each\n * filter is indexed using the token which was the *least seen* globally. In\n * other words, we pick the most discriminative token for each filter. This is\n * done using the following algorithm:\n *   1. Tokenize all the filters which will be stored in the index\n *   2. Compute a histogram of frequency of each token (globally)\n *   3. Select the best token for each filter (lowest frequency)\n */\nexport default class ReverseIndex {\n    static deserialize(buffer, deserialize, optimize, config) {\n        const tokensLookupIndexSize = buffer.getUint32();\n        const bucketsIndexSize = buffer.getUint32();\n        const numberOfFilters = buffer.getUint32();\n        // Alignement to 4 bytes is important here since `view` (Uint8Array) can\n        // appear at any offset of `buffer`. But to be sure we can read back\n        // Uint32Array directly from raw buffer, the alignement has to be a\n        // multiple of 4. The same alignement is taken care of in `serialize`.\n        const view = StaticDataView.fromUint8Array(buffer.getBytes(true /* align */), config);\n        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);\n        const filtersIndexStart = view.pos;\n        view.seekZero(); // not strictly needed but make sure reverse index can be compared with deep equal\n        return new ReverseIndex({\n            config,\n            deserialize,\n            filters: [],\n            optimize,\n        }).updateInternals({\n            bucketsIndex,\n            filtersIndexStart,\n            numberOfFilters,\n            tokensLookupIndex,\n            view,\n        });\n    }\n    constructor({ deserialize, filters, optimize, config, }) {\n        // Internal, compact representation of the reverse index. It contains three\n        // distinct parts stored in the same typed array:\n        //\n        // 1. \"tokens lookup index\" allows to identify a sub-set of buckets which\n        // likely contain filters for a given token. It is an approximate dispatch\n        // table which maps a mask of N bits (N being smaller than 31 bits, the size\n        // of a token) to a list of buckets having a 'token' sharing these same N\n        // bits sub-set. If the binary representation of the token for bucket1 is\n        // 101010 and suffix has size 3, then we would lookup the \"tokens lookup\n        // index\" using the last 3 bits \"010\" which would give us the offset in our\n        // typed array where we can start reading the filters of buckets having a\n        // token ending with the same 3 bits. The value of N is always a power of 2\n        // depending on the total number of filters stored in the index; determined\n        // at the time `update(...)` is called.\n        //\n        // 2. \"buckets index\" is an array which associates tokens to filters. The\n        // structure is: token, filter, token, filter, etc. To identify all the\n        // filters indexed with 'token' a naive approach would be to iterate on\n        // \"buckets index\" and collect all the filters indexed with 'token'. This\n        // would be *very inefficient*! To make this process faster, filters in\n        // \"buckets index\" are grouped so that buckets sharing the same suffix of N\n        // bits in their indexing token (see \"tokens lookup index\") are stored side\n        // by side in the typed array. To know where this section start given a\n        // particular token, we use \"tokens lookup index\" which associated the suffix\n        // of size N to an index in \"buckets index\". From there we can iterate on the\n        // candidates.\n        //\n        // 3. \"filters index\" contains the filters themselves. \"buckets index\"\n        // presented earlier does not contain filters, but an index to the \"filters\n        // index\". This allows a filter to be indexed multiple times without\n        // introducing any overhead; the filter can be associated with multiple\n        // tokens in \"buckets index\" (each pointing to the same place in \"filters\n        // index\") but its actual representation is stored only once in \"filters\n        // index\".\n        this.bucketsIndex = EMPTY_UINT32_ARRAY;\n        this.filtersIndexStart = 0;\n        this.numberOfFilters = 0;\n        this.tokensLookupIndex = EMPTY_UINT32_ARRAY;\n        // In-memory cache used to keep track of buckets which have been loaded from\n        // the compact representation (i.e.: this.view). It is not strictly necessary\n        // but will speed-up retrival of popular filters (since we do not have to\n        // perform the lookup in \"tokens index\" and \"buckets index\" everytime).\n        this.cache = new Map();\n        this.view = StaticDataView.empty(config);\n        this.deserializeFilter = deserialize;\n        this.optimize = optimize;\n        this.config = config;\n        if (filters.length !== 0) {\n            this.update(filters, undefined);\n        }\n    }\n    /**\n     * Load all filters from this index in memory (i.e.: deserialize them from\n     * the byte array into NetworkFilter or CosmeticFilter instances). This is\n     * mostly useful for debugging or testing purposes.\n     */\n    getFilters() {\n        const filters = [];\n        if (this.numberOfFilters === 0) {\n            return filters;\n        }\n        // set view cursor at the start of \"filters index\"\n        this.view.setPos(this.filtersIndexStart);\n        for (let i = 0; i < this.numberOfFilters; i += 1) {\n            filters.push(this.deserializeFilter(this.view));\n        }\n        this.view.seekZero();\n        return filters;\n    }\n    /**\n     * Return an array of all the tokens currently used as keys of the \"buckets index\".\n     */\n    getTokens() {\n        const tokens = new Set();\n        for (let i = 0; i < this.bucketsIndex.length; i += 2) {\n            tokens.add(this.bucketsIndex[i]);\n        }\n        return new Uint32Array(tokens);\n    }\n    /**\n     * Estimate the number of bytes needed to serialize this instance of `ReverseIndex`.\n     */\n    getSerializedSize() {\n        // 12 = 4 bytes (tokensLookupIndex.length) + 4 bytes (bucketsIndex.length) + 4 bytes (numberOfFilters)\n        return 12 + sizeOfBytes(this.view.buffer, true /* align */);\n    }\n    /**\n     * Dump this index to `buffer`.\n     */\n    serialize(buffer) {\n        buffer.pushUint32(this.tokensLookupIndex.length);\n        buffer.pushUint32(this.bucketsIndex.length);\n        buffer.pushUint32(this.numberOfFilters);\n        // Aligmenent is crucial here, see comment in `deserialize` for more info.\n        buffer.pushBytes(this.view.buffer, true /* align */);\n    }\n    /**\n     * Iterate on all filters found in buckets associated with the given list of\n     * tokens. The callback is called on each of them. Early termination can be\n     * achieved if the callback returns `false`.\n     *\n     * This will not check if each filter returned would match a given request but\n     * is instead used as a list of potential candidates (much smaller than the\n     * total set of filters; typically between 5 and 10 filters will be checked).\n     */\n    iterMatchingFilters(tokens, cb) {\n        // Each request is assigned an ID so that we can keep track of the last\n        // request seen by each bucket in the reverse index. This provides a cheap\n        // way to prevent filters from being inspected more than once per request\n        // (which could happen if the same token appears more than once in the URL).\n        const requestId = getNextId();\n        for (const token of tokens) {\n            if (this.iterBucket(token, requestId, cb) === false) {\n                return;\n            }\n        }\n        // Fallback to 0 (i.e.: wildcard bucket) bucket if nothing was found before.\n        this.iterBucket(0, requestId, cb);\n    }\n    /**\n     * Re-create the internal data-structure of the reverse index *in-place*. It\n     * needs to be called with a list of new filters and optionally a list of ids\n     * (as returned by either NetworkFilter.getId() or CosmeticFilter.getId())\n     * which need to be removed from the index.\n     */\n    update(newFilters, removedFilters) {\n        // Reset internal cache on each update\n        if (this.cache.size !== 0) {\n            this.cache.clear();\n        }\n        const compression = this.config.enableCompression;\n        let totalNumberOfTokens = 0;\n        let totalNumberOfIndexedFilters = 0;\n        const filtersTokens = [];\n        // Keep track of the final size of the buckets index. `bucketsIndexSize` is\n        // the number of indexed filters, multiplied by 2 (since we store both the\n        // token a filter is indexed with and the index of the filter).\n        let bucketsIndexSize = 0;\n        // Re-use the current size of \"filters index\" as a starting point so that\n        // we only need to update with new or removed filters. This saves time if\n        // we perform a small update on an existing index.\n        let estimatedBufferSize = this.view.buffer.byteLength - this.filtersIndexStart;\n        // Create a list of all filters which will be part of the index. This means\n        // loading existing filters, removing the ones that need to be deleted and\n        // adding the new ones.  At the same time, we update the estimation of\n        // buffer size needed to store this index.\n        let filters = this.getFilters();\n        if (filters.length !== 0) {\n            // If there is at least one existing filter, then we check if some should\n            // be removed. We subtract their size from the total estimated buffer\n            // size.\n            if (removedFilters !== undefined && removedFilters.size !== 0) {\n                filters = filters.filter((f) => {\n                    if (removedFilters.has(f.getId())) {\n                        estimatedBufferSize -= f.getSerializedSize(compression);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            // Add new filters to the list and also update estimated size\n            for (const filter of newFilters) {\n                estimatedBufferSize += filter.getSerializedSize(compression);\n                filters.push(filter);\n            }\n        }\n        else {\n            // In the case where there is no existing filter in the index (happens on\n            // initialization), then we can take a fast-path and not check removed\n            // filters at all. There is also no need to copy the array of filters.\n            filters = newFilters;\n            for (const filter of newFilters) {\n                estimatedBufferSize += filter.getSerializedSize(compression);\n            }\n        }\n        // No filters given; reset to empty index and abort.\n        if (filters.length === 0) {\n            this.updateInternals({\n                bucketsIndex: EMPTY_UINT32_ARRAY,\n                filtersIndexStart: 0,\n                numberOfFilters: 0,\n                tokensLookupIndex: EMPTY_UINT32_ARRAY,\n                view: StaticDataView.empty(this.config),\n            });\n            return;\n        }\n        // When we run in `debug` mode, we enable fully deterministic updates of\n        // internal data-structures. To this effect, we sort all filters before\n        // insertion.\n        if (this.config.debug === true) {\n            filters.sort((f1, f2) => f1.getId() - f2.getId());\n        }\n        const histogram = new Uint32Array(Math.max(nextPow2(2 * filters.length), 256));\n        // Tokenize all filters stored in this index. And compute a histogram of\n        // tokens so that we can decide how to index each filter efficiently.\n        for (const filter of filters) {\n            // Tokenize `filter` and store the result in `filtersTokens` which will\n            // be used in the next step to select the best token for each filter.\n            const multiTokens = filter.getTokens();\n            filtersTokens.push(multiTokens);\n            // Update estimated size of \"buckets index\" based on number of times this\n            // particular filter will be indexed.\n            bucketsIndexSize += 2 * multiTokens.length; // token + filter index\n            totalNumberOfIndexedFilters += multiTokens.length;\n            // Each filter can be indexed more than once, so `getTokens(...)` returns\n            // multiple sets of tokens. We iterate on all of them and update the\n            // histogram for each.\n            for (const tokens of multiTokens) {\n                totalNumberOfTokens += tokens.length;\n                for (const token of tokens) {\n                    histogram[token % histogram.length] += 1;\n                }\n            }\n        }\n        // Add size of bucketsIndex to total size (x4 because these are 32 bits numbers)\n        estimatedBufferSize += bucketsIndexSize * 4;\n        // Prepare \"tokens index\" (see documentation in constructor of `ReverseIndex` class above).\n        const tokensLookupIndexSize = Math.max(2, nextPow2(totalNumberOfIndexedFilters));\n        const mask = tokensLookupIndexSize - 1;\n        const suffixes = [];\n        for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n            suffixes.push([]);\n        }\n        // Add size of tokensLookupIndex to total size (x4 because these are 32 bits numbers)\n        estimatedBufferSize += tokensLookupIndexSize * 4;\n        // At this point we know the number of bytes needed for the compact\n        // representation of this reverse index (\"tokens index\" + \"buckets index\" +\n        // \"filters index\"). We allocate it at once and proceed with populating it.\n        const buffer = StaticDataView.allocate(estimatedBufferSize, this.config);\n        const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);\n        const filtersIndexStart = buffer.getPos();\n        // For each filter, find the best token (least seen) based on histogram.\n        // Since we are iterating again on the filters, we populate \"filters index\"\n        // in the same loop and keep track of their indices so that we can later\n        // populate \"buckets index\".\n        for (let i = 0; i < filtersTokens.length; i += 1) {\n            const filter = filters[i];\n            const multiTokens = filtersTokens[i];\n            // Serialize this filter and keep track of its index in the byte array;\n            // it will be used in \"buckets index\" to point to this filter.\n            const filterIndex = buffer.pos;\n            filter.serialize(buffer);\n            // Index the filter once per \"tokens\"\n            for (const tokens of multiTokens) {\n                // Find best token (least seen) from `tokens` using `histogram`.\n                let bestToken = 0; // default = wildcard bucket\n                let minCount = totalNumberOfTokens + 1;\n                for (const token of tokens) {\n                    const tokenCount = histogram[token % histogram.length];\n                    if (tokenCount < minCount) {\n                        minCount = tokenCount;\n                        bestToken = token;\n                        // Fast path, if the current token has only been seen once, we can\n                        // stop iterating since we will not find a better alternarive!\n                        if (minCount === 1) {\n                            break;\n                        }\n                    }\n                }\n                // `bestToken & mask` represents the N last bits of `bestToken`. We\n                // group all filters indexed with a token sharing the same N bits.\n                suffixes[bestToken & mask].push([bestToken, filterIndex]);\n            }\n        }\n        // Populate \"tokens index\" and \"buckets index\" based on best token found for each filter.\n        let indexInBucketsIndex = 0;\n        for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n            const filtersForMask = suffixes[i];\n            tokensLookupIndex[i] = indexInBucketsIndex;\n            for (const [token, filterIndex] of filtersForMask) {\n                bucketsIndex[indexInBucketsIndex++] = token;\n                bucketsIndex[indexInBucketsIndex++] = filterIndex;\n            }\n        }\n        // Update internals\n        buffer.seekZero();\n        this.updateInternals({\n            bucketsIndex,\n            filtersIndexStart,\n            numberOfFilters: filtersTokens.length,\n            tokensLookupIndex,\n            view: buffer,\n        });\n    }\n    updateInternals({ bucketsIndex, filtersIndexStart, numberOfFilters, tokensLookupIndex, view, }) {\n        this.bucketsIndex = bucketsIndex;\n        this.filtersIndexStart = filtersIndexStart;\n        this.numberOfFilters = numberOfFilters;\n        this.tokensLookupIndex = tokensLookupIndex;\n        this.view = view;\n        view.seekZero();\n        return this;\n    }\n    /**\n     * If a bucket exists for the given token, call the callback on each filter\n     * found inside. An early termination mechanism is built-in, to stop iterating\n     * as soon as `false` is returned from the callback.\n     */\n    iterBucket(token, requestId, cb) {\n        let bucket = this.config.enableInMemoryCache === true ? this.cache.get(token) : undefined;\n        // Lazily create bucket if it does not yet exist in memory. Lookup the\n        // compact bucket representation and find all filters being associated with\n        // `token`. Create a `Bucket` out of them and store them in cache.\n        if (bucket === undefined) {\n            const offset = token & (this.tokensLookupIndex.length - 1);\n            const startOfBucket = this.tokensLookupIndex[offset];\n            // We do not have any filters for this token\n            if (startOfBucket === EMPTY_BUCKET) {\n                return true;\n            }\n            // Since we do not store explicitly the number of filters in each\n            // \"bucket\", we check the index of the next one and use it to infer the\n            // number of filters (each filter being stored as a token + index to the\n            // \"filters store\")\n            const endOfBucket = offset === this.tokensLookupIndex.length - 1\n                ? this.bucketsIndex.length\n                : this.tokensLookupIndex[offset + 1];\n            // Get indices of filters indexed with `token`, if any.\n            const filtersIndices = [];\n            for (let i = startOfBucket; i < endOfBucket; i += 2) {\n                const currentToken = this.bucketsIndex[i];\n                if (currentToken === token) {\n                    filtersIndices.push(this.bucketsIndex[i + 1]);\n                }\n            }\n            // No filter indexed with `token`.\n            if (filtersIndices.length === 0) {\n                return true; // continue looking for a match\n            }\n            // If we have filters for `token` then deserialize filters in memory and\n            // create a `Bucket` instance to hold them for future access.\n            const filters = [];\n            const view = this.view;\n            for (let i = 0; i < filtersIndices.length; i += 1) {\n                view.setPos(filtersIndices[i]);\n                filters.push(this.deserializeFilter(view));\n            }\n            // Create new bucket with found filters (only optimize if we have more\n            // than one filter).\n            bucket = {\n                filters: filters.length > 1 ? this.optimize(filters) : filters,\n                lastRequestSeen: -1, // safe because all ids are positive\n            };\n            if (this.config.enableInMemoryCache === true) {\n                this.cache.set(token, bucket);\n            }\n        }\n        // Look for matching filter in this bucket\n        if (bucket.lastRequestSeen !== requestId) {\n            bucket.lastRequestSeen = requestId;\n            const filters = bucket.filters;\n            for (let i = 0; i < filters.length; i += 1) {\n                // Break the loop if the callback returns `false`\n                if (cb(filters[i]) === false) {\n                    // Whenever we get a match from a filter, we also swap it one\n                    // position up in the list. This way, over time, popular filters will\n                    // be first and might match earlier. This should decrease the time\n                    // needed to get a match.\n                    if (i > 0) {\n                        const filter = filters[i];\n                        filters[i] = filters[i - 1];\n                        filters[i - 1] = filter;\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=reverse-index.js.map"],"names":["StaticDataView","EMPTY_UINT32_ARRAY","sizeOfBytes"],"mappings":"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"}