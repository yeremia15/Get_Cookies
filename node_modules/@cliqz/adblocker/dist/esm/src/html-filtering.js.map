{"version":3,"file":"html-filtering.js","sources":["../../src/src/html-filtering.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function extractHTMLSelectorFromRule(rule) {\n    if (rule.startsWith('^script') === false) {\n        return undefined;\n    }\n    const prefix = ':has-text(';\n    const selectors = [];\n    let index = 7;\n    // ^script:has-text\n    //        ^ 7\n    // Prepare for finding one or more ':has-text(' selectors in a row\n    while (rule.startsWith(prefix, index)) {\n        index += prefix.length;\n        let currentParsingDepth = 1;\n        const startOfSelectorIndex = index;\n        let prev = -1; // previous character\n        for (; index < rule.length && currentParsingDepth !== 0; index += 1) {\n            const code = rule.charCodeAt(index);\n            if (prev !== 92 /* '\\' */) {\n                if (code === 40 /* '(' */) {\n                    currentParsingDepth += 1;\n                }\n                if (code === 41 /* ')' */) {\n                    currentParsingDepth -= 1;\n                }\n            }\n            prev = code;\n        }\n        selectors.push(rule.slice(startOfSelectorIndex, index - 1));\n    }\n    if (index !== rule.length) {\n        return undefined;\n    }\n    return ['script', selectors];\n}\nexport function extractTagsFromHtml(html, tag) {\n    const tags = [];\n    const prefix = `<${tag}`;\n    const suffix = `</${tag}>`;\n    // Keep track of the beginning of current identified tag\n    let index = html.indexOf(prefix);\n    // Keep tracks of index immediately following last extracted tag\n    let endOfLastTag = 0;\n    while (index !== -1) {\n        // Find index of end of current tag. If we do not find it, it could be\n        // because it will come in the next chunk and we should try parsing it\n        // again then.\n        const endOfTagIndex = html.indexOf('>', index + prefix.length);\n        if (endOfTagIndex === -1) {\n            return [tags, html.slice(0, index), html.slice(index)];\n        }\n        // Handle short tag form <tag/> which will not have a closing tag.\n        if (html.charCodeAt(endOfTagIndex - 1) === 47 /* '/' */) {\n            endOfLastTag = endOfTagIndex + 1;\n            tags.push([index, html.slice(index, endOfLastTag)]);\n        }\n        else {\n            // Find index of closing tag '</tag>'. If we do not find it, again, it\n            // could mean that it will come in next chunk and we need to try parsing\n            // it again with more input.\n            const indexOfClosingTag = html.indexOf(suffix, endOfTagIndex);\n            if (indexOfClosingTag === -1) {\n                return [tags, html.slice(0, index), html.slice(index)];\n            }\n            tags.push([index, html.slice(index, indexOfClosingTag + suffix.length)]);\n            endOfLastTag = indexOfClosingTag + suffix.length;\n        }\n        index = html.indexOf(prefix, endOfLastTag);\n    }\n    // Make sure we consume as much input as possible so that we do not parse the\n    // same portion of HTML again next time and we can stream chunks as early as\n    // possible.\n    //\n    // We check if there is at least one '<' char after the end of the last\n    // extracted tag; this would indicate that the next chunk might contain the\n    // remaining of a valid tag. We then look up to N characters after this '<'\n    // character, where N is the size of 'prefix'. The rational is that if we\n    // reached this part of the code, then it cannot be a match otherwise we\n    // would have returned earlier (from the loop).\n    let lastClosingTagIndex = html.lastIndexOf('>');\n    if (lastClosingTagIndex === -1) {\n        lastClosingTagIndex = endOfLastTag;\n    }\n    const indexOfNextTag = html.indexOf('<', lastClosingTagIndex);\n    // If no '<' in the remaining of input, then it means we can count this chunk\n    // as fully parsed (i.e.: next chunk can be parsed independently without\n    // missing a tag which would start in this one).\n    if (indexOfNextTag === -1) {\n        return [tags, html, ''];\n    }\n    // In case of a partial tag ending this 'html' chunk. Then check if we have\n    // enough information to discard it already based on the kind of tags we are\n    // looking for.\n    if (html.length - indexOfNextTag >= prefix.length ||\n        prefix.startsWith(html.slice(indexOfNextTag)) === false) {\n        return [tags, html, ''];\n    }\n    return [tags, html.slice(0, indexOfNextTag), html.slice(indexOfNextTag)];\n}\nexport function extractSelectorsFromRules(filter) {\n    const patterns = [];\n    for (const [, selectors] of filter) {\n        const plainPatterns = [];\n        const regexpPatterns = [];\n        for (const selector of selectors) {\n            if (selector.charCodeAt(0) === 47 /* '/' */) {\n                if (selector.endsWith('/')) {\n                    regexpPatterns.push(new RegExp(selector.slice(1, -1)));\n                }\n                else if (selector.endsWith('/i')) {\n                    regexpPatterns.push(new RegExp(selector.slice(1, -2), 'i'));\n                }\n            }\n            else {\n                plainPatterns.push(selector);\n            }\n        }\n        if (plainPatterns.length !== 0 || regexpPatterns.length !== 0) {\n            patterns.push([plainPatterns, regexpPatterns]);\n        }\n    }\n    return patterns;\n}\n/**\n * Check if `tag` should be removed from HTML based on `plainPatterns` and\n * `regexpPatterns`. For a tag to be removed, all elements from `plainPatterns`\n * and `regexpPatterns` must match.\n */\nfunction tagShouldBeRemoved(tag, plainPatterns, regexpPatterns) {\n    for (const pattern of plainPatterns) {\n        if (tag.indexOf(pattern) === -1) {\n            return false;\n        }\n    }\n    for (const pattern of regexpPatterns) {\n        if (pattern.test(tag) === false) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function selectTagsToRemove(patterns, tags) {\n    const toRemove = [];\n    for (const tag of tags) {\n        for (const [plainPatterns, regexpPatterns] of patterns) {\n            if (tagShouldBeRemoved(tag[1], plainPatterns, regexpPatterns)) {\n                toRemove.push(tag);\n                break;\n            }\n        }\n    }\n    return toRemove;\n}\nexport function removeTagsFromHtml(html, toRemove) {\n    if (toRemove.length === 0) {\n        return html;\n    }\n    let filteredHtml = html;\n    toRemove.reverse(); // make sure to remove from last to first tag (preserve indices)\n    for (const [index, tag] of toRemove) {\n        filteredHtml = filteredHtml.slice(0, index) + filteredHtml.slice(index + tag.length);\n    }\n    return filteredHtml;\n}\nexport default class StreamingHtmlFilter {\n    constructor(selectors) {\n        this.buffer = '';\n        this.patterns = extractSelectorsFromRules(selectors);\n    }\n    flush() {\n        return this.buffer;\n    }\n    write(chunk) {\n        // If there are no valid selectors, abort.\n        if (this.patterns.length === 0) {\n            return chunk;\n        }\n        // If given an empty string, abort.\n        if (chunk.length === 0) {\n            return chunk;\n        }\n        // Accumulate buffer + new data\n        this.buffer += chunk;\n        // Parse tags from `this.buffer`\n        const [tags, parsed, rest] = extractTagsFromHtml(this.buffer, 'script');\n        this.buffer = rest;\n        // If no tags were found, just return the parsed version\n        if (tags.length === 0) {\n            return parsed;\n        }\n        // Perform tags filtering using `this.patterns` and `this.regexps`.\n        return removeTagsFromHtml(parsed, selectTagsToRemove(this.patterns, tags));\n    }\n}\n//# sourceMappingURL=html-filtering.js.map"],"names":[],"mappings":"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"}