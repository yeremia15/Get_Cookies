{"version":3,"file":"punycode.js","sources":["../../src/src/punycode.js"],"sourcesContent":["/*!\n * Copyright Mathias Bynens <https://mathiasbynens.be/>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n/** Regular expressions */\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nconst errors = {\n    'invalid-input': 'Invalid input',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'overflow': 'Overflow: input needs wider integers to process',\n};\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\n/*--------------------------------------------------------------------------*/\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n    throw new RangeError(errors[type]);\n}\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(str) {\n    const output = [];\n    let counter = 0;\n    const length = str.length;\n    while (counter < length) {\n        const value = str.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = str.charCodeAt(counter++);\n            if ((extra & 0xfc00) === 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nfunction basicToDigit(codePoint) {\n    if (codePoint - 0x30 < 0x0a) {\n        return codePoint - 0x16;\n    }\n    if (codePoint - 0x41 < 0x1a) {\n        return codePoint - 0x41;\n    }\n    if (codePoint - 0x61 < 0x1a) {\n        return codePoint - 0x61;\n    }\n    return base;\n}\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nfunction digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26 ? 1 : 0) - ((flag !== 0 ? 1 : 0) << 5);\n}\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nfunction adapt(delta, numPoints, firstTime) {\n    let k = 0;\n    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;\n    delta += Math.floor(delta / numPoints);\n    for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {\n        delta = Math.floor(delta / baseMinusTMin);\n    }\n    return Math.floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));\n}\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nexport function decode(input) {\n    // Don't use UCS-2.\n    const output = [];\n    const inputLength = input.length;\n    let i = 0;\n    let n = initialN;\n    let bias = initialBias;\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n    let basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n    for (let j = 0; j < basic; ++j) {\n        // if it's not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n            error('not-basic');\n        }\n        output.push(input.charCodeAt(j));\n    }\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */;) {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        const oldi = i;\n        for (let w = 1, k = base /* no condition */;; k += base) {\n            if (index >= inputLength) {\n                error('invalid-input');\n            }\n            const digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > Math.floor((maxInt - i) / w)) {\n                error('overflow');\n            }\n            i += digit * w;\n            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n                break;\n            }\n            const baseMinusT = base - t;\n            if (w > Math.floor(maxInt / baseMinusT)) {\n                error('overflow');\n            }\n            w *= baseMinusT;\n        }\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi === 0);\n        // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we'll fix that now:\n        if (Math.floor(i / out) > maxInt - n) {\n            error('overflow');\n        }\n        n += Math.floor(i / out);\n        i %= out;\n        // Insert `n` at position `i` of the output.\n        output.splice(i++, 0, n);\n    }\n    return String.fromCodePoint.apply(null, output);\n}\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nexport function encode(str) {\n    const output = [];\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    const input = ucs2decode(str);\n    // Cache the length.\n    const inputLength = input.length;\n    // Initialize the state.\n    let n = initialN;\n    let delta = 0;\n    let bias = initialBias;\n    // Handle the basic code points.\n    for (let i = 0; i < input.length; i += 1) {\n        const currentValue = input[i];\n        if (currentValue < 0x80) {\n            output.push(String.fromCharCode(currentValue));\n        }\n    }\n    const basicLength = output.length;\n    let handledCPCount = basicLength;\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n        output.push(delimiter);\n    }\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        let m = maxInt;\n        for (let i = 0; i < input.length; i += 1) {\n            const currentValue = input[i];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error('overflow');\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (let i = 0; i < input.length; i += 1) {\n            const currentValue = input[i];\n            if (currentValue < n && ++delta > maxInt) {\n                error('overflow');\n            }\n            if (currentValue === n) {\n                // Represent delta as a generalized variable-length integer.\n                let q = delta;\n                for (let k = base /* no condition */;; k += base) {\n                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    const qMinusT = q - t;\n                    const baseMinusT = base - t;\n                    output.push(String.fromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));\n                    q = Math.floor(qMinusT / baseMinusT);\n                }\n                output.push(String.fromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n        ++delta;\n        ++n;\n    }\n    return output.join('');\n}\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nexport function toUnicode(input) {\n    const labels = input.replace(regexSeparators, '\\x2E').split('.');\n    const encoded = [];\n    for (let i = 0; i < labels.length; i += 1) {\n        encoded.push(labels[i].startsWith('xn--') ? decode(labels[i].slice(4).toLowerCase()) : labels[i]);\n    }\n    return encoded.join('.');\n}\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nexport function toASCII(input) {\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    const labels = input.replace(regexSeparators, '\\x2E').split('.');\n    const encoded = [];\n    for (let i = 0; i < labels.length; i += 1) {\n        encoded.push(regexNonASCII.test(labels[i]) ? 'xn--' + encode(labels[i]) : labels[i]);\n    }\n    return encoded.join('.');\n}\n/**\n * A string representing the current Punycode.js version number.\n * @memberOf punycode\n * @type String\n */\nexport const version = '2.1.0';\n//# sourceMappingURL=punycode.js.map"],"names":[],"mappings":"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"}