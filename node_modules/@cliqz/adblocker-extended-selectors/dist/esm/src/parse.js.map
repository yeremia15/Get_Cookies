{"version":3,"file":"parse.js","sources":["../../src/src/parse.js"],"sourcesContent":["/*!\n * Based on parsel. Extended by Rémi Berson for Ghostery (2021).\n * https://github.com/LeaVerou/parsel\n *\n * MIT License\n *\n * Copyright (c) 2020 Lea Verou\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { isAST, isAtoms } from './types';\nexport const RECURSIVE_PSEUDO_CLASSES = new Set([\n    'any',\n    'dir',\n    'has',\n    'host-context',\n    'if',\n    'if-not',\n    'is',\n    'matches',\n    'not',\n    'where',\n]);\nconst TOKENS = {\n    attribute: /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(?<caseSensitive>[iIsS])?\\s*)?\\]/gu,\n    id: /#(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    class: /\\.(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    comma: /\\s*,\\s*/g, // must be before combinator\n    combinator: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n    'pseudo-element': /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?:¶*)\\))?/gu, // this must be before pseudo-class\n    'pseudo-class': /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>¶*)\\))?/gu,\n    type: /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu, // this must be last\n};\nconst TOKENS_WITH_PARENS = new Set(['pseudo-class', 'pseudo-element']);\nconst TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, 'attribute']);\nconst TRIM_TOKENS = new Set(['combinator', 'comma']);\nconst TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);\nTOKENS_FOR_RESTORE['pseudo-element'] = RegExp(TOKENS['pseudo-element'].source.replace('(?<argument>¶*)', '(?<argument>.*?)'), 'gu');\nTOKENS_FOR_RESTORE['pseudo-class'] = RegExp(TOKENS['pseudo-class'].source.replace('(?<argument>¶*)', '(?<argument>.*)'), 'gu');\n// TODO - it feels like with some more typing shenanigans we could replace groups validation by generic logic in this function.\nfunction splitOnMatch(pattern, str) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(str);\n    if (match === null) {\n        return undefined;\n    }\n    const from = match.index - 1;\n    const content = match[0];\n    const before = str.slice(0, from + 1);\n    const after = str.slice(from + content.length + 1);\n    return [before, [content, match.groups || {}], after];\n}\nconst GRAMMAR = [\n    // attribute\n    (str) => {\n        const match = splitOnMatch(TOKENS.attribute, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, operator, value, namespace, caseSensitive }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'attribute',\n                content,\n                length: content.length,\n                namespace,\n                caseSensitive,\n                pos: [],\n                name,\n                operator,\n                value,\n            },\n            after,\n        ];\n    },\n    // #id\n    (str) => {\n        const match = splitOnMatch(TOKENS.id, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'id',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // .class\n    (str) => {\n        const match = splitOnMatch(TOKENS.class, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // comma ,\n    (str) => {\n        const match = splitOnMatch(TOKENS.comma, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'comma',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // combinator\n    (str) => {\n        const match = splitOnMatch(TOKENS.combinator, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'combinator',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // pseudo-element\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-element'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-element',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // pseudo-class\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-class'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        // TODO - here `argument` can be undefined and should be rejected?\n        const [before, [content, { name, argument }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n                argument,\n                subtree: undefined,\n            },\n            after,\n        ];\n    },\n    // type\n    (str) => {\n        const match = splitOnMatch(TOKENS.type, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, namespace }], after] = match;\n        return [\n            before,\n            {\n                type: 'type',\n                content,\n                length: content.length,\n                namespace,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n];\nfunction tokenizeBy(text) {\n    if (!text) {\n        return [];\n    }\n    const strarr = [text];\n    for (const tokenizer of GRAMMAR) {\n        for (let i = 0; i < strarr.length; i++) {\n            const str = strarr[i];\n            if (typeof str === 'string') {\n                const match = tokenizer(str);\n                if (match !== undefined) {\n                    strarr.splice(i, 1, ...match.filter((a) => a.length !== 0));\n                }\n            }\n        }\n    }\n    let offset = 0;\n    for (const token of strarr) {\n        if (typeof token !== 'string') {\n            token.pos = [offset, offset + token.length];\n            if (TRIM_TOKENS.has(token.type)) {\n                token.content = token.content.trim() || ' ';\n            }\n        }\n        offset += token.length;\n    }\n    if (isAtoms(strarr)) {\n        return strarr;\n    }\n    // NOTE: here this means that parsing failed.\n    return [];\n}\nfunction restoreNested(tokens, strings, regex, types) {\n    // TODO - here from offsets in strings and tokens we should be able to find the exact spot without RegExp?\n    for (const str of strings) {\n        for (const token of tokens) {\n            if (types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {\n                const content = token.content;\n                token.content = token.content.replace(regex, str.str);\n                if (token.content !== content) {\n                    // actually changed?\n                    // Re-evaluate groups\n                    TOKENS_FOR_RESTORE[token.type].lastIndex = 0;\n                    const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);\n                    if (match !== null) {\n                        Object.assign(token, match.groups);\n                    }\n                }\n            }\n        }\n    }\n}\nexport function isEscaped(str, index) {\n    let backslashes = 0;\n    index -= 1;\n    while (index >= 0 && str[index] === '\\\\') {\n        backslashes += 1;\n        index -= 1;\n    }\n    return backslashes % 2 !== 0;\n}\nexport function gobbleQuotes(text, quote, start) {\n    // Find end of quote, taking care of ignoring escaped quotes\n    let end = start + 1;\n    while ((end = text.indexOf(quote, end)) !== -1 && isEscaped(text, end) === true) {\n        end += 1;\n    }\n    if (end === -1) {\n        // Opening quote without closing quote\n        return undefined;\n    }\n    return text.slice(start, end + 1);\n}\nexport function gobbleParens(text, start) {\n    let stack = 0;\n    for (let i = start; i < text.length; i++) {\n        const char = text[i];\n        if (char === '(') {\n            stack += 1;\n        }\n        else if (char === ')') {\n            if (stack > 0) {\n                stack -= 1;\n            }\n            else {\n                // Closing paren without opening paren\n                return undefined;\n            }\n        }\n        if (stack === 0) {\n            return text.slice(start, i + 1);\n        }\n    }\n    // Opening paren without closing paren\n    return undefined;\n}\nexport function replace(selector, replacement, opening, gobble) {\n    const strings = [];\n    let offset = 0;\n    while ((offset = selector.indexOf(opening, offset)) !== -1) {\n        const str = gobble(selector, offset);\n        if (str === undefined) {\n            break;\n        }\n        strings.push({ str, start: offset });\n        selector = `${selector.slice(0, offset + 1)}${replacement.repeat(str.length - 2)}${selector.slice(offset + str.length - 1)}`;\n        offset += str.length;\n    }\n    return [strings, selector];\n}\nexport function tokenize(selector) {\n    if (typeof selector !== 'string') {\n        return [];\n    }\n    // Prevent leading/trailing whitespace be interpreted as combinators\n    selector = selector.trim();\n    if (selector.length === 0) {\n        return [];\n    }\n    // Replace strings with whitespace strings (to preserve offsets)\n    const [doubleQuotes, selectorWithoutDoubleQuotes] = replace(selector, '§', '\"', (text, start) => gobbleQuotes(text, '\"', start));\n    const [singleQuotes, selectorWithoutQuotes] = replace(selectorWithoutDoubleQuotes, '§', \"'\", (text, start) => gobbleQuotes(text, \"'\", start));\n    // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n    const [parens, selectorWithoutParens] = replace(selectorWithoutQuotes, '¶', '(', gobbleParens);\n    // Now we have no nested structures and we can parse with regexes\n    const tokens = tokenizeBy(selectorWithoutParens);\n    // Now restore parens and strings in reverse order\n    restoreNested(tokens, parens, /\\(¶*\\)/, TOKENS_WITH_PARENS);\n    restoreNested(tokens, doubleQuotes, /\"§*\"/, TOKENS_WITH_STRINGS);\n    restoreNested(tokens, singleQuotes, /'§*'/, TOKENS_WITH_STRINGS);\n    return tokens;\n}\n// Convert a flat list of tokens into a tree of complex & compound selectors\nfunction nestTokens(tokens, { list = true } = {}) {\n    if (list === true && tokens.some((t) => t.type === 'comma')) {\n        const selectors = [];\n        const temp = [];\n        for (let i = 0; i < tokens.length; i += 1) {\n            const token = tokens[i];\n            if (token.type === 'comma') {\n                if (temp.length === 0) {\n                    throw new Error('Incorrect comma at ' + i);\n                }\n                const sub = nestTokens(temp, { list: false });\n                if (sub !== undefined) {\n                    selectors.push(sub);\n                }\n                temp.length = 0;\n            }\n            else {\n                temp.push(token);\n            }\n        }\n        if (temp.length === 0) {\n            throw new Error('Trailing comma');\n        }\n        else {\n            const sub = nestTokens(temp, { list: false });\n            if (sub !== undefined) {\n                selectors.push(sub);\n            }\n        }\n        return { type: 'list', list: selectors };\n    }\n    for (let i = tokens.length - 1; i >= 0; i--) {\n        const token = tokens[i];\n        if (token.type === 'combinator') {\n            const left = nestTokens(tokens.slice(0, i));\n            const right = nestTokens(tokens.slice(i + 1));\n            if (right === undefined) {\n                return undefined;\n            }\n            if (token.content !== ' ' &&\n                token.content !== '~' &&\n                token.content !== '+' &&\n                token.content !== '>') {\n                return undefined;\n            }\n            return {\n                type: 'complex',\n                combinator: token.content,\n                left,\n                right,\n            };\n        }\n    }\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    if (isAST(tokens)) {\n        if (tokens.length === 1) {\n            return tokens[0];\n        }\n        // If we're here, there are no combinators, so it's just a list\n        return {\n            type: 'compound',\n            compound: [...tokens], // clone to avoid pointers messing up the AST\n        };\n    }\n    return undefined;\n}\n// Traverse an AST (or part thereof), in depth-first order\nfunction walk(node, callback, o, parent) {\n    if (node === undefined) {\n        return;\n    }\n    if (node.type === 'complex') {\n        walk(node.left, callback, o, node);\n        walk(node.right, callback, o, node);\n    }\n    else if (node.type === 'compound') {\n        for (const n of node.compound) {\n            walk(n, callback, o, node);\n        }\n    }\n    else if (node.type === 'pseudo-class' &&\n        node.subtree !== undefined &&\n        o !== undefined &&\n        o.type === 'pseudo-class' &&\n        o.subtree !== undefined) {\n        walk(node.subtree, callback, o, node);\n    }\n    callback(node, parent);\n}\n/**\n * Parse a CSS selector\n * @param selector {String} The selector to parse\n * @param options.recursive {Boolean} Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.\n * @param options.list {Boolean} Whether this can be a selector list (A, B, C etc). Defaults to true.\n */\nexport function parse(selector, { recursive = true, list = true } = {}) {\n    const tokens = tokenize(selector);\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    const ast = nestTokens(tokens, { list });\n    if (recursive === true) {\n        walk(ast, (node) => {\n            if (node.type === 'pseudo-class' &&\n                node.argument &&\n                node.name !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n                node.subtree = parse(node.argument, { recursive: true, list: true });\n            }\n        });\n    }\n    return ast;\n}\n//# sourceMappingURL=parse.js.map"],"names":[],"mappings":"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"}